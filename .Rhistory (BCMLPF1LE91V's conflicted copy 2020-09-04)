, trend_discount = seq(from = 0.95, to = 1, by = 0.01)
, alpha = seq(from = 0, to = 1, by = 0.10))
grid_glm <- expand_grid(time_weight = seq(from = 0.8, to = 1, by = 0.02)
, trend_discount = seq(from = 0.8, to = 1, by = 0.02))
parameter <- list(glmnet = list(time_weight = .94, trend_discount = .70, alpha = 0, lambda = .1
, grid_glmnet = grid_glmnet
, job = list(optim_lambda = TRUE, x_excluded = NULL
, random_search_size = 0.05
, n_best_model = 1))
, croston = list(alpha = 0.1)
, glm = list(time_weight = .99, trend_discount = 0.70
, grid_glm = grid_glm
, job = list(x_excluded = NULL
, random_search_size = 0.1
, n_best_model = 1))
, arima = list(p = 1, d = 1, q = 0, P = 1, D = 0, Q = 0)
, ets = list(ets = "ZZZ"))
data_init <- read_csv("test_source/demo_data.csv") %>%
dplyr::filter(date < "2020-02-01"
, forecast_item != "FI: 34142")
data_all <- data_init %>%
prescribe_ts(key = "forecast_item", y_var = "volume", date_var = "date"
, freq = 12, reg_name = "reg_name", reg_value = "reg_value")
model_list <- c("glm","glmnet","arima","ets","dynamic_theta","seasonal_naive","croston")
cluster = makeCluster(4, type = "SOCK")
registerDoSNOW(cluster)
ntasks <- length(unique(data_all$key)[1:5])
progress <- function(n) {
cat(sprintf(" %d Keys(s) / %.2f%% percent remaining\n",ntasks-n,(ntasks-n)*100/ntasks))
}
opts <- list(progress=progress)
tictoc::tic()
results <- foreach(key_i = unique(data_all$key)[1:5], .combine = "rbind", .options.snow=opts
, .packages=pkg
) %dopar% {
data_i <- data_all[data_all$key == key_i,]
autoforecast(.data = data_i, horizon = 100
, model = model_list
, parameter = parameter, optim_profile = "fast", test_size = 6
, lag = 3, meta_data = FALSE, method = "winsorize", tune_parallel = TRUE)
}
tictoc::toc()
results
results %>%
plot_ts(multiple_keys = T, interactive = T)
results
results %>% attributes()
results %>%
plot_ts(multiple_keys = T, interactive = T)
.optim_output <- results
prescription <- attributes(.optim_output)[["prescription"]]
if(attributes(.data)[["output_type"]] != "optim_output"){
stop("Error, the input data is not class optim_output")
} else {
# key
subtitle <- paste0("Selected Key:"," ",unique(.data$key))
# graph
graph_tmp <- .data %>%
ggplot(aes(date_var, y_var, col = model), size = 1.0005)+
geom_line(size = 1.0005)+
labs(x = "", y = "y_var", col = "Model")+
geom_vline(xintercept = as.Date(prescription$max_date), linetype ="dashed")+
scale_y_continuous(n.breaks = 10, minor_breaks = NULL)+
scale_x_date(expand = c(0,0),date_breaks = "2 month", minor_breaks = NULL)+
theme_bw() +
theme(plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
plot.subtitle = element_text(size = 13, hjust = 0.5, face = "bold"),
axis.text.x = element_text(size = 11, angle = 45, hjust = 1),
axis.title = element_text(size = 13, hjust = 0.5, face = "bold"),
legend.position = "right",
legend.title = element_text(size = 15),
legend.text = element_text(size = 13)) +
labs(x="Time",y="Sales", title = "Generated Forecast", subtitle = subtitle) +
if(multiple_keys == TRUE){
graph_tmp <- graph_tmp +
facet_wrap( ~ key, scales = "free")
}
if(interactive == TRUE){
ggplotly(graph_tmp)
} else {
graph_tmp
}
}
# key
subtitle <- paste0("Selected Key:"," ",unique(.optim_output$key))
.optim_output$key
unique(.optim_output$key)
# key
subtitle <- paste0("Selected Key:"," ", unique(.optim_output$key))
.optim_output %>%
ggplot(aes(date_var, y_var, col = model), size = 1.0005)+
geom_line(size = 1.0005)+
labs(x = "", y = "y_var", col = "Model")+
geom_vline(xintercept = as.Date(prescription$max_date), linetype ="dashed")+
scale_y_continuous(n.breaks = 10, minor_breaks = NULL)+
scale_x_date(expand = c(0,0),date_breaks = "2 month", minor_breaks = NULL)+
theme_bw()
.optim_output %>%
ggplot(aes(date_var, y_var, col = model), size = 1.0005)+
geom_line(size = 1.0005)+
labs(x = "", y = "y_var", col = "Model")+
geom_vline(xintercept = as.Date(prescription$max_date), linetype ="dashed")+
scale_y_continuous(n.breaks = 10, minor_breaks = NULL)+
scale_x_date(expand = c(0,0),date_breaks = "2 month", minor_breaks = NULL)+
theme_bw() +
theme(plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
plot.subtitle = element_text(size = 13, hjust = 0.5, face = "bold"),
axis.text.x = element_text(size = 11, angle = 45, hjust = 1),
axis.title = element_text(size = 13, hjust = 0.5, face = "bold"),
legend.position = "right",
legend.title = element_text(size = 15),
legend.text = element_text(size = 13)) +
labs(x="Time",y="Sales", title = "Generated Forecast", subtitle = subtitle)
#'
#' @import ggplot2
#' @importFrom plotly ggplotly
#' @return graph
#' @export
#'
#' @examples
#' \dontrun{
#' plot_ts()
#' }
plot_ts <- function(.optim_output, interactive = FALSE, multiple_keys = FALSE){
prescription <- attributes(.optim_output)[["prescription"]]
if(attributes(.data)[["output_type"]] != "optim_output"){
stop("Error, the input data is not class optim_output")
} else {
# key
subtitle <- paste0("Selected Key:"," ", unique(.optim_output$key))
# graph
graph_tmp <- .optim_output %>%
ggplot(aes(date_var, y_var, col = model), size = 1.0005)+
geom_line(size = 1.0005)+
labs(x = "", y = "y_var", col = "Model")+
geom_vline(xintercept = as.Date(prescription$max_date), linetype ="dashed")+
scale_y_continuous(n.breaks = 10, minor_breaks = NULL)+
scale_x_date(expand = c(0,0),date_breaks = "2 month", minor_breaks = NULL)+
theme_bw() +
theme(plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
plot.subtitle = element_text(size = 13, hjust = 0.5, face = "bold"),
axis.text.x = element_text(size = 11, angle = 45, hjust = 1),
axis.title = element_text(size = 13, hjust = 0.5, face = "bold"),
legend.position = "right",
legend.title = element_text(size = 15),
legend.text = element_text(size = 13)) +
labs(x="Time",y="Sales", title = "Generated Forecast", subtitle = subtitle)
if(multiple_keys == TRUE){
graph_tmp <- graph_tmp +
facet_wrap( ~ key, scales = "free")
}
if(interactive == TRUE){
ggplotly(graph_tmp)
} else {
graph_tmp
}
}
}
results %>%
plot_ts(multiple_keys = T, interactive = T)
#'
#' @import ggplot2
#' @importFrom plotly ggplotly
#' @return graph
#' @export
#'
#' @examples
#' \dontrun{
#' plot_ts()
#' }
plot_ts <- function(.optim_output, interactive = FALSE, multiple_keys = FALSE){
prescription <- attributes(.optim_output)[["prescription"]]
if(attributes(.optim_output)[["output_type"]] != "optim_output"){
stop("Error, the input data is not class optim_output")
} else {
# key
subtitle <- paste0("Selected Key:"," ", unique(.optim_output$key))
# graph
graph_tmp <- .optim_output %>%
ggplot(aes(date_var, y_var, col = model), size = 1.0005)+
geom_line(size = 1.0005)+
labs(x = "", y = "y_var", col = "Model")+
geom_vline(xintercept = as.Date(prescription$max_date), linetype ="dashed")+
scale_y_continuous(n.breaks = 10, minor_breaks = NULL)+
scale_x_date(expand = c(0,0),date_breaks = "2 month", minor_breaks = NULL)+
theme_bw() +
theme(plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
plot.subtitle = element_text(size = 13, hjust = 0.5, face = "bold"),
axis.text.x = element_text(size = 11, angle = 45, hjust = 1),
axis.title = element_text(size = 13, hjust = 0.5, face = "bold"),
legend.position = "right",
legend.title = element_text(size = 15),
legend.text = element_text(size = 13)) +
labs(x="Time",y="Sales", title = "Generated Forecast", subtitle = subtitle)
if(multiple_keys == TRUE){
graph_tmp <- graph_tmp +
facet_wrap( ~ key, scales = "free")
}
if(interactive == TRUE){
ggplotly(graph_tmp)
} else {
graph_tmp
}
}
}
results %>%
plot_ts(multiple_keys = T, interactive = T)
prescription <- attributes(.optim_output)[["prescription"]]
if(attributes(.optim_output)[["output_type"]] != "optim_output"){
stop("Error, the input data is not class optim_output")
} else {
# key
subtitle <- paste0("Selected Key:"," ", unique(.optim_output$key))
# graph
graph_tmp <- .optim_output %>%
ggplot(aes(date_var, y_var, col = model), size = 1.0005)+
geom_line(size = 1.0005)+
labs(x = "", y = "y_var", col = "Model")+
geom_vline(xintercept = as.Date(prescription$max_date), linetype ="dashed")+
scale_y_continuous(n.breaks = 10, minor_breaks = NULL)+
scale_x_date(expand = c(0,0),date_breaks = "2 month", minor_breaks = NULL)+
theme_bw() +
theme(plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
plot.subtitle = element_text(size = 13, hjust = 0.5, face = "bold"),
axis.text.x = element_text(size = 11, angle = 45, hjust = 1),
axis.title = element_text(size = 13, hjust = 0.5, face = "bold"),
legend.position = "right",
legend.title = element_text(size = 15),
legend.text = element_text(size = 13)) +
labs(x="Time",y="Sales", title = "Generated Forecast", subtitle = subtitle)
if(multiple_keys == TRUE){
graph_tmp <- graph_tmp +
facet_wrap( ~ key, scales = "free")
}
if(interactive == TRUE){
ggplotly(graph_tmp)
} else {
graph_tmp
}
}
results %>%
plot_ts(multiple_keys = T, interactive = T)
tictoc::tic()
results <- foreach(key_i = unique(data_all$key)[1:5], .combine = "rbind", .options.snow=opts
, .packages=pkg
) %dopar% {
data_i <- data_all[data_all$key == key_i,]
autoforecast(.data = data_i, horizon = 36
, model = model_list
, parameter = parameter, optim_profile = "fast", test_size = 6
, lag = 3, meta_data = FALSE, method = "winsorize", tune_parallel = TRUE)
}
tictoc::toc()
stopCluster(cl)
results %>%
plot_ts(multiple_keys = T, interactive = T)
#'
#' @import ggplot2
#' @importFrom plotly ggplotly
#' @return graph
#' @export
#'
#' @examples
#' \dontrun{
#' plot_ts()
#' }
plot_ts <- function(.optim_output, interactive = FALSE, multiple_keys = FALSE){
prescription <- attributes(.optim_output)[["prescription"]]
if(attributes(.optim_output)[["output_type"]] != "optim_output"){
stop("Error, the input data is not class optim_output")
} else {
# key
subtitle <- paste0("Selected Key:"," ", unique(.optim_output$key))
# graph
graph_tmp <- .optim_output %>%
ggplot(aes(date_var, y_var, col = model), size = 1.0005)+
geom_line(size = 1.0005)+
labs(x = "", y = "y_var", col = "Model")+
geom_vline(xintercept = as.Date(prescription$max_date), linetype ="dashed")+
scale_y_continuous(n.breaks = 10, minor_breaks = NULL)+
scale_x_date(expand = c(0,0), date_breaks = "4 months", minor_breaks = NULL)+
theme_bw() +
theme(plot.title = element_text(size = 16, hjust = 0.5, face = "bold"),
plot.subtitle = element_text(size = 13, hjust = 0.5, face = "bold"),
axis.text.x = element_text(size = 11, angle = 45, hjust = 1),
axis.title = element_text(size = 13, hjust = 0.5, face = "bold"),
legend.position = "right",
legend.title = element_text(size = 15),
legend.text = element_text(size = 13)) +
labs(x="Time",y="Sales", title = "Generated Forecast", subtitle = subtitle)
if(multiple_keys == TRUE){
graph_tmp <- graph_tmp +
facet_wrap( ~ key, scales = "free")
}
if(interactive == TRUE){
ggplotly(graph_tmp)
} else {
graph_tmp
}
}
}
results %>%
plot_ts(multiple_keys = T, interactive = T)
results <- foreach(key_i = unique(data_all$key)[1:5], .combine = "rbind", .options.snow=opts
, .packages=pkg
) %dopar% {
data_i <- data_all[data_all$key == key_i,]
autoforecast(.data = data_i, horizon = 36
, model = model_list
, parameter = parameter, optim_profile = "fast", test_size = 6
, lag = 3, meta_data = FALSE, method = "winsorize",top_models = 2, tune_parallel = TRUE)
}
results %>%
plot_ts(multiple_keys = T, interactive = T)
tictoc::tic()
results <- foreach(key_i = unique(data_all$key)[1:5], .combine = "rbind", .options.snow=opts
, .packages=pkg
) %dopar% {
data_i <- data_all[data_all$key == key_i,]
autoforecast(.data = data_i, horizon = 36
, model = model_list
, parameter = parameter, optim_profile = "light", test_size = 6
, lag = 3, meta_data = FALSE, method = "winsorize",top_models = 2, tune_parallel = TRUE)
}
tictoc::toc()
results %>%
plot_ts(multiple_keys = T, interactive = T)
pkg <- c("glmnet", "forecast", "stlplus", "fastDummies", "imputeTS", "plotly",
"tidyverse", "doParallel", "foreach", "parallel", "tsibble", "doSNOW",
"prophet","forecTheta","autoforecast")
lapply(pkg, require, character.only = TRUE)
grid_glmnet <- expand_grid(time_weight = seq(from = 0.9, to = 1, by = 0.02)
, trend_discount = seq(from = 0.95, to = 1, by = 0.01)
, alpha = seq(from = 0, to = 1, by = 0.10))
grid_glm <- expand_grid(time_weight = seq(from = 0.8, to = 1, by = 0.02)
, trend_discount = seq(from = 0.8, to = 1, by = 0.02))
parameter <- list(glmnet = list(time_weight = .94, trend_discount = .70, alpha = 0, lambda = .1
, grid_glmnet = grid_glmnet
, job = list(optim_lambda = TRUE, x_excluded = NULL
, random_search_size = 0.05
, n_best_model = 1))
, croston = list(alpha = 0.1)
, glm = list(time_weight = .99, trend_discount = 0.70
, grid_glm = grid_glm
, job = list(x_excluded = NULL
, random_search_size = 0.1
, n_best_model = 1))
, arima = list(p = 1, d = 1, q = 0, P = 1, D = 0, Q = 0)
, ets = list(ets = "ZZZ"))
data_init <- read_csv("test_source/demo_data.csv") %>%
dplyr::filter(date < "2020-02-01"
, forecast_item != "FI: 34142")
data_all <- data_init %>%
prescribe_ts(key = "forecast_item", y_var = "volume", date_var = "date"
, freq = 12, reg_name = "reg_name", reg_value = "reg_value")
model_list <- c("glm","glmnet","arima","ets","dynamic_theta","seasonal_naive","croston")
cluster = makeCluster(4, type = "SOCK")
registerDoSNOW(cluster)
ntasks <- length(unique(data_all$key)[1:5])
progress <- function(n) {
cat(sprintf(" %d Keys(s) / %.2f%% percent remaining\n",ntasks-n,(ntasks-n)*100/ntasks))
}
opts <- list(progress=progress)
tictoc::tic()
results <- foreach(key_i = unique(data_all$key)[1:5], .combine = "rbind", .options.snow=opts
, .packages=pkg
) %dopar% {
data_i <- data_all[data_all$key == key_i,]
autoforecast(.data = data_i, horizon = 36
, model = model_list
, parameter = parameter, optim_profile = "light", test_size = 6
, lag = 3, meta_data = FALSE, method = "winsorize",top_models = 2, tune_parallel = TRUE)
}
tictoc::toc()
results %>%
plot_ts(multiple_keys = T, interactive = T)
.data <- data_all %>%
dplyr::filter(key == "FI: 515188") #%>%
fast_optim_forecast <- autoforecast(.data = .data
, horizon = 36
, model = model_list
, parameter = parameter
, optim_profile = "fast"
, method = "kalman")
fast_optim_forecast %>%
plot_ts(interactive = F)
light_optim_forecast <- autoforecast(.data = .data
, horizon = 100
, model = model_list
, parameter = parameter
, optim_profile = "light"
, test_size = 6
, lag = 3
, meta_data = FALSE
, tune_parallel = FALSE
, method = "winsorize") # since meta_data = T, a list will be printed.
model_list <- c("glm", "glmnet", "neural_network", "arima", "ets",
"seasonal_naive"
#, "croston", "tbats", "dynamic_theta",
"tslm"
)
model_list <- c("glm", "glmnet", "neural_network", "arima", "ets",
"seasonal_naive"
#, "croston", "tbats", "dynamic_theta",
#"tslm"
)
light_optim_forecast <- autoforecast(.data = .data
, horizon = 100
, model = model_list
, parameter = parameter
, optim_profile = "light"
, test_size = 6
, lag = 3
, meta_data = FALSE
, tune_parallel = FALSE
, method = "winsorize") # since meta_data = T, a list will be printed.
model_list <- c("glm", "glmnet", "neural_network", "arima", "ets",
"seasonal_naive"
, "croston"
#, "tbats", "dynamic_theta",
#"tslm"
)
model_list <- c(#"glm", "glmnet", "neural_network", "arima", "ets",
"seasonal_naive"
, "croston"
#, "tbats", "dynamic_theta",
#"tslm"
)
light_optim_forecast <- autoforecast(.data = .data
, horizon = 100
, model = model_list
, parameter = parameter
, optim_profile = "light"
, test_size = 6
, lag = 3
, meta_data = FALSE
, tune_parallel = FALSE
, method = "winsorize") # since meta_data = T, a list will be printed.
model_list <- c("croston")
light_optim_forecast <- autoforecast(.data = .data
, horizon = 100
, model = model_list
, parameter = parameter
, optim_profile = "light"
, test_size = 6
, lag = 3
, meta_data = FALSE
, tune_parallel = FALSE
, method = "winsorize") # since meta_data = T, a list will be printed.
model_list <- c("tbats")
light_optim_forecast <- autoforecast(.data = .data
, horizon = 100
, model = model_list
, parameter = parameter
, optim_profile = "light"
, test_size = 6
, lag = 3
, meta_data = FALSE
, tune_parallel = FALSE
, method = "winsorize") # since meta_data = T, a list will be printed.
model_list <- c("dynamic_theta")
light_optim_forecast <- autoforecast(.data = .data
, horizon = 100
, model = model_list
, parameter = parameter
, optim_profile = "light"
, test_size = 6
, lag = 3
, meta_data = FALSE
, tune_parallel = FALSE
, method = "winsorize") # since meta_data = T, a list will be printed.
model_list <- c("glmnet")
light_optim_forecast <- autoforecast(.data = .data
, horizon = 100
, model = model_list
, parameter = parameter
, optim_profile = "light"
, test_size = 6
, lag = 3
, meta_data = FALSE
, tune_parallel = FALSE
, method = "winsorize") # since meta_data = T, a list will be printed.
pkg <- c("glmnet", "forecast", "stlplus", "fastDummies", "imputeTS", "plotly"
, "tidyverse", "doParallel", "foreach", "parallel", "tsibble", "doSNOW", "autoforecast")
lapply(pkg, require, character.only = TRUE)
grid_glmnet <- expand_grid(time_weight = seq(from = 0.9, to = 1, by = 0.02)
, trend_discount = seq(from = 0.95, to = 1, by = 0.01)
, alpha = seq(from = 0, to = 1, by = 0.10))
grid_glm <- expand_grid(time_weight = seq(from = 0.8, to = 1, by = 0.02)
, trend_discount = seq(from = 0.8, to = 1, by = 0.02))
parameter <- list(glmnet = list(time_weight = .94, trend_discount = .70, alpha = 0, lambda = .1
, grid_glmnet = grid_glmnet
, job = list(optim_lambda = TRUE, x_excluded = NULL
, random_search_size = 0.05
, n_best_model = 1))
, croston = list(alpha = 0.1)
, glm = list(time_weight = .99, trend_discount = 0.70
, grid_glm = grid_glm
, job = list(x_excluded = NULL
, random_search_size = 0.1
, n_best_model = 1))
, arima = list(p = 1, d = 1, q = 0, P = 1, D = 0, Q = 0)
, ets = list(ets = "ZZZ"))
data_init <- read_csv("demo_data.csv") %>%
dplyr::filter(date < "2020-02-01"
, forecast_item != "FI: 34142")
data_init <- read_csv("test_source/demo_data.csv") %>%
dplyr::filter(date < "2020-02-01"
, forecast_item != "FI: 34142")
read_csv("test_source/demo_data.csv") %>%
dplyr::filter(date < "2020-02-01"
, forecast_item != "FI: 34142")
